<!DOCTYPE html>
<html>
<head>
	<title>Cobra de berlim</title>
	<<style type="text/css" >
		canvas {
			display: block;
			position: absolute;
			border: 1px solid #000;
			margin: auto;
			top: 0;
			bottom: 0;
			right: 0;
			left: 0;
		}
	</style>
</head>
<body>

<script charset="utf-8" async defer>
	//Constants
	var COLS = 26, ROWS = 26;

	// Ids 
	var EMPTY = 0, SNAKE = 1, FRUIT =2, FASTER = 3, SLOWER = 4;

	//Directions
	var LEFT = 0, UP = 1, RIGHT = 2, DOWN = 3;

	//KeyCodes
	var KEY_LEFT = 37, KEY_UP = 38, KEY_RIGHT = 39, KEY_DOWN = 40;

	//Speed
	var NORMAL = 5, FAST = 2

	var grid = {

		width : null,
		height: null,
		_grid: null,

		init: function(d, c, r)  {
			this.width = c;
			this.height = r;
			this._grid = [];

			for(var x = 0; x< c; x++) {
				this._grid.push([]);
				for(var y = 0; y < r; y++) {
					this._grid[x].push(d);
				}
			}
		},

		set: function(val, x, y){			
			this._grid[x][y] = val;
		},

		get: function(x, y)  {
			return this._grid[x][y];
		}
	}

	var snake1 = {

		direction: null,
		last: null,
		_queue: null,
		speed: NORMAL,

		init: function(d, x, y) {
			this.direction = d;

			this._queue = [];
			this.insert(x, y);
		},

		insert: function(x, y)  {
			this._queue.unshift({ x:x, y:y});
			this.last = this._queue[0];
		},

		remove: function() {
			return this._queue.pop();
		}		
	}

	function setFood() {
		var empty = [];
		for(var x = 0; x < grid.width; x++) {
			for(var y = 0; y < grid.height; y++) {
				if(grid.get(x, y) === EMPTY) {
					empty.push({x:x, y:y});					
				}
			}
		}
		var randpos = empty[Math.floor(Math.random()*empty.length)];		
		grid.set(FRUIT, randpos.x, randpos.y);
	}

	function setFasterTerrain() {
		var empty = [];
		for(var x = 0; x < grid.width; x++) {
			for(var y = 0; y < grid.height; y++) {
				if(grid.get(x, y) === EMPTY) {
					empty.push({x:x, y:y});					
				}
			}
		}
		var randpos = empty[Math.floor(Math.random()*empty.length)];		
		grid.set(FASTER, randpos.x, randpos.y);		
	}

	function setSlowerTerrain() {
		var empty = [];
		for(var x = 0; x < grid.width; x++) {
			for(var y = 0; y < grid.height; y++) {
				if(grid.get(x, y) === EMPTY) {
					empty.push({x:x, y:y});					
				}
			}
		}
		var randpos = empty[Math.floor(Math.random()*empty.length)];		
		grid.set(SLOWER, randpos.x, randpos.y);		
	}

	//Game objects
	var canvas, ctx, keystate, frames;

	function main() {
		canvas = document.createElement("canvas");
		canvas.width = COLS * 20;
		canvas.height = ROWS * 20;
		ctx = canvas.getContext("2d");
		document.body.appendChild(canvas);
		console.log(document.body);

		frames = 0;
		framesInc = 1;
		keystate = {};

		document.addEventListener("keydown", function(evt){
			keystate[evt.keyCode] = true;					
		});

		document.addEventListener("keyup", function(evt) {
			delete keystate[evt.keyCode];
		});

		init();
		loop();
	}

	function init() {
		grid.init(EMPTY, COLS, ROWS);
		setFasterTerrain();		

		var sp = {x: Math.floor(COLS/2), y:ROWS -1};
		snake1.init(UP, sp.x, sp.y);
		grid.set(SNAKE, sp.x, sp.y);
		snake1.speed = NORMAL;

		setFood();
	}

	function loop() {
		update();
		draw();

		window.requestAnimationFrame(loop, canvas);
	}

	//Atualiza a posição
	function update() {
		frames++;
		if(keystate[KEY_LEFT] && snake1.direction !== RIGHT) snake1.direction = LEFT;
		if(keystate[KEY_UP] && snake1.direction !== DOWN) snake1.direction = UP;
		if(keystate[KEY_RIGHT] && snake1.direction !== LEFT) snake1.direction = RIGHT;
		if(keystate[KEY_DOWN] && snake1.direction !== UP) snake1.direction = DOWN;

		//O número de frames determina a velocidade do jogo
		if(frames%snake1.speed === 0) {			
			var nx = snake1.last.x;
			var ny = snake1.last.y;

			switch (snake1.direction) {
				case LEFT:					
					nx--;
					break;
				case UP:
					ny--;
					break;
				case RIGHT:
					nx++;
					break;
				case DOWN:
					ny++;
					break;				
			}	
			if( 0 > nx || nx > grid.width -1 ||
				0 > ny || ny > grid.height - 1 ||
				grid.get(nx, ny) === SNAKE)  {				
				return init();
			}	

			if(grid.get(nx, ny) == FRUIT) {				
				console.log(snake1._queue)				
				var tail = {x:nx, y:ny};
				setFood();
			} else{				
				var tail = snake1.remove();
				grid.set(EMPTY, tail.x, tail.y);
				tail.x = nx;
				tail.y = ny;
			}	

			if(grid.get(nx, ny) == FASTER) {				
				snake1.speed = FAST;	
				setFasterTerrain();	
				setSlowerTerrain();
			}

			if(grid.get(nx, ny) == SLOWER) {				
				snake1.speed = NORMAL;					
			}		

			grid.set(SNAKE, tail.x, tail.y);
			snake1.insert(tail.x, tail.y);
		}	
	}

	// function checkIfBodyHasFruit(snake) {
	// 	let hasFruit = false;
	// 	snake._queue.every(function(element) {
	// 		if(grid.get(element.x, element.y) == FRUIT) {
	// 			hasFruit = true;
	// 			return false;
	// 		} else {
	// 			return true;
	// 		}
	// 	});

	// 	return hasFruit;
	// }

	function checkIfHeadGetFruit(nx, ny, snake) {
		let getFruit = false;
		switch (snake1.direction) {
			case LEFT:					
				for(let inc = snake.speed; inc > 0; inc--) {
					if(grid.get(nx + inc, ny) == FRUIT) {
						getFruit = true;
					}
				}
				break;
			case UP:
				for(let inc = snake.speed; inc > 0; inc--) {
					if(grid.get(nx, ny + inc) == FRUIT){
						getFruit = true;
					}
				}					
				break;
			case RIGHT:
				for(let inc = snake.speed; inc > 0; inc--) {
					if(grid.get(nx - inc, ny ) == FRUIT){
						getFruit = true;
					}
				}					
				break;
			case DOWN:
				for(let inc = snake.speed; inc > 0; inc--) {
					if(grid.get(nx, ny - inc) == FRUIT){
						getFruit = true;
					}
				}							
				break;				
		}	
		return getFruit;
	}


	function draw() {
		var tw = canvas.width/grid.width;
		var th = canvas.height/grid.height;
		
		for(var x = 0; x < grid.width; x++) {
			for(var y = 0; y < grid.height; y++) {			
				switch(grid.get(x, y)) {
					case EMPTY:
						ctx.fillStyle = "#fff";
						break;
					case SNAKE:
						ctx.fillStyle = "#0ff";
						break;
					case FRUIT:
						ctx.fillStyle = "#f00";
						break;
					case FASTER:
						ctx.fillStyle = "#111";
						break;
					case SLOWER:
						ctx.fillStyle = "#a99";
						break;
				}										
				ctx.fillRect(x * tw, y * th, tw, th);	
			}
		}
	}
	main();

</script>
</body>
</html>