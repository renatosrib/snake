<!DOCTYPE html>
<html>
<head>
	<title>Cobra de berlim</title>
	<<style type="text/css" >
		canvas {
			display: block;
			position: absolute;
			border: 1px solid #000;
			margin: auto;
			top: 0;
			bottom: 0;
			right: 0;
			left: 0;
		}
	</style>
</head>
<body>
<<p>
	Press enter to restart!
</p>
<script charset="utf-8" async defer>
	//Constants
	var COLS = 26, ROWS = 26;

	// Ids
	var EMPTY = 0, WALL = 1, FRUIT =2, FASTER = 3, SLOWER = 4 , SNAKE1 = 5, SNAKE2 = 6 ,WALL = 7;

	//Directions
	var LEFT = 0, UP = 1, RIGHT = 2, DOWN = 3;

	//KeyCodes
	var KEY_LEFT1 = 37, KEY_UP1 = 38, KEY_RIGHT1 = 39, KEY_DOWN1 = 40;
	var KEY_LEFT2 = 65, KEY_UP2 = 87, KEY_RIGHT2 = 68, KEY_DOWN2 = 83;
	var BLOCK_1 = 16, BLOCK_2 = 32;

	//Speed
	var STOPED = -1, NORMAL = 5, FAST = 2;

	var BEGIN = 13;

	var grid = {

		width : null,
		height: null,
		_grid: null,

		init: function(d, c, r)  {
			this.width = c;
			this.height = r;
			this._grid = [];

			for(var x = 0; x< c; x++) {
				this._grid.push([]);
				for(var y = 0; y < r; y++) {
					this._grid[x].push(d);
				}
			}
		},

		set: function(val, x, y){
			this._grid[x][y] = val;
		},

		get: function(x, y)  {
			return this._grid[x][y];
		}
	}

	var snake1 = {

		direction: null,
		last: null,
		_queue: null,
		speed: NORMAL,

		init: function(d, x, y) {
			this.direction = d;

			this._queue = [];
			this.insert(x, y);
		},

		insert: function(x, y)  {
			this._queue.unshift({ x:x, y:y});
			this.last = this._queue[0];
		},

		remove: function() {
			return this._queue.pop();
		}
	}

	var snake2 = {

		direction: null,
		last: null,
		_queue: null,
		speed: NORMAL,

		init: function(d, x, y) {
			this.direction = d;

			this._queue = [];
			this.insert(x, y);
		},

		insert: function(x, y)  {
			this._queue.unshift({ x:x, y:y});
			this.last = this._queue[0];
		},

		remove: function() {
			return this._queue.pop();
		}
	}


	function setFood() {
		var empty = [];
		for(var x = 0; x < grid.width; x++) {
			for(var y = 0; y < grid.height; y++) {
				if(grid.get(x, y) === EMPTY) {
					empty.push({x:x, y:y});
				}
			}
		}
		var randpos = empty[Math.floor(Math.random()*empty.length)];
		grid.set(FRUIT, randpos.x, randpos.y);
	}

	function setFasterTerrain() {
		var empty = [];
		for(var x = 0; x < grid.width; x++) {
			for(var y = 0; y < grid.height; y++) {
				if(grid.get(x, y) === EMPTY) {
					empty.push({x:x, y:y});
				}
			}
		}
		var randpos = empty[Math.floor(Math.random()*empty.length)];
		grid.set(FASTER, randpos.x, randpos.y);
	}

	function setSlowerTerrain() {
		var empty = [];
		for(var x = 0; x < grid.width; x++) {
			for(var y = 0; y < grid.height; y++) {
				if(grid.get(x, y) === EMPTY) {
					empty.push({x:x, y:y});
				}
			}
		}
		var randpos = empty[Math.floor(Math.random()*empty.length)];
		grid.set(SLOWER, randpos.x, randpos.y);
	}

	//Game objects
	var canvas, ctx, keystate, frames;

	function main() {
		canvas = document.createElement("canvas");
		canvas.width = COLS * 20;
		canvas.height = ROWS * 20;
		ctx = canvas.getContext("2d");
		document.body.appendChild(canvas);
		console.log(document.body);

		frames = 0;
		framesInc = 1;
		keystate = {};

		document.addEventListener("keydown", function(evt){
			keystate[evt.keyCode] = true;
		});

		document.addEventListener("keyup", function(evt) {
			delete keystate[evt.keyCode];
		});

		init();
		loop();
	}

	function init() {
		if(snake1.speed !== STOPED && snake2.speed !== STOPED){
			grid.init(EMPTY, COLS, ROWS);
			setFasterTerrain();

			var sp1 = {x: Math.floor(COLS/2), y:ROWS -1};
			snake1.init(UP, sp1.x, sp1.y);
			grid.set(SNAKE1, sp1.x, sp1.y);
			snake1.speed = NORMAL;

			var sp2 = {x: Math.floor(COLS-1), y:ROWS /2};
			snake2.init(UP, sp2.x, sp2.y);
			grid.set(SNAKE2, sp2.x, sp2.y);
			snake2.speed = NORMAL;

			setFood();
		}
		
	}

	function loop() {


		update();
		draw();

		window.requestAnimationFrame(loop, canvas);
	}

	//Atualiza a posição
	function update() {
		frames++;
		if(keystate[KEY_LEFT1] && snake1.direction !== RIGHT) snake1.direction = LEFT;
		if(keystate[KEY_UP1] && snake1.direction !== DOWN) snake1.direction = UP;
		if(keystate[KEY_RIGHT1] && snake1.direction !== LEFT) snake1.direction = RIGHT;
		if(keystate[KEY_DOWN1] && snake1.direction !== UP) snake1.direction = DOWN;

		if(keystate[KEY_LEFT2] && snake2.direction !== RIGHT) snake2.direction = LEFT;
		if(keystate[KEY_UP2] && snake2.direction !== DOWN) snake2.direction = UP;
		if(keystate[KEY_RIGHT2] && snake2.direction !== LEFT) snake2.direction = RIGHT;
		if(keystate[KEY_DOWN2] && snake2.direction !== UP) snake2.direction = DOWN;

		var putBlock1 = false, putBlock2 = false;
		if(keystate[BLOCK_1] && snake1._queue.length >1) putBlock1 = true;
		if(keystate[BLOCK_2] && snake2._queue.length >1) putBlock2 = true;

		if(keystate[BEGIN]) continueGame();



		//O número de frames determina a velocidade do jogo

		if(frames%snake1.speed === 0 && snake1.speed !== STOPED) {
			var nx = snake1.last.x;
			var ny = snake1.last.y;

			switch (snake1.direction) {
				case LEFT:
					nx--;
					break;
				case UP:
					ny--;
					break;
				case RIGHT:
					nx++;
					break;
				case DOWN:
					ny++;
					break;
			}
			if( 0 > nx || nx > grid.width -1 ||
				0 > ny || ny > grid.height - 1 ||
				grid.get(nx, ny) === SNAKE1 ||
				grid.get(nx, ny) === SNAKE2 ||
				grid.get(nx, ny) === WALL)  {
				stopGame();
				return init();
			}

			if(grid.get(nx, ny) == FRUIT) {
				console.log(snake1._queue)
				var tail = {x:nx, y:ny};
				setFood();
			} else{
				var tail = snake1.remove();
				grid.set(EMPTY, tail.x, tail.y);
				tail.x = nx;
				tail.y = ny;
			}

			if(grid.get(nx, ny) == FASTER) {
				snake1.speed = FAST;
				setFasterTerrain();
				setSlowerTerrain();
			}

			if(grid.get(nx, ny) == SLOWER) {
				snake1.speed = NORMAL;
			}

			grid.set(SNAKE1, tail.x, tail.y);
			snake1.insert(tail.x, tail.y);
			if(putBlock1){
					var tail = snake1.remove();
					grid.set(WALL, tail.x, tail.y);
			}
		}

		if(frames%snake2.speed === 0 && snake2.speed !== STOPED) {
			var nx = snake2.last.x;
			var ny = snake2.last.y;

			switch (snake2.direction) {
				case LEFT:
					nx--;
					break;
				case UP:
					ny--;
					break;
				case RIGHT:
					nx++;
					break;
				case DOWN:
					ny++;
					break;
			}
			if( 0 > nx || nx > grid.width -1 ||
				0 > ny || ny > grid.height - 1 ||
				grid.get(nx, ny) === SNAKE1 ||
				grid.get(nx, ny) === SNAKE2 ||
				grid.get(nx, ny) === WALL)  {
				stopGame();
				return init();
			}

			if(grid.get(nx, ny) == FRUIT) {
				console.log(snake2._queue)
				var tail = {x:nx, y:ny};
				setFood();
			} else{
				var tail = snake2.remove();
				grid.set(EMPTY, tail.x, tail.y);
				tail.x = nx;
				tail.y = ny;
			}

			if(grid.get(nx, ny) == FASTER) {
				snake2.speed = FAST;
				setFasterTerrain();
				setSlowerTerrain();
			}

			if(grid.get(nx, ny) == SLOWER) {
				snake2.speed = NORMAL;
			}

			grid.set(SNAKE2, tail.x, tail.y);
			snake2.insert(tail.x, tail.y);

			if(putBlock2){
				var tail = snake2.remove();
				grid.set(WALL, tail.x, tail.y);
			}
		}
	}

	function draw() {
		var tw = canvas.width/grid.width;
		var th = canvas.height/grid.height;

		for(var x = 0; x < grid.width; x++) {
			for(var y = 0; y < grid.height; y++) {
				switch(grid.get(x, y)) {
					case EMPTY:
						ctx.fillStyle = "#fff";
						break;
					case WALL:
						ctx.fillStyle = "#009B3A";
						break;
					case FRUIT:
						ctx.fillStyle = "#f00";
						break;
					case FASTER:
						ctx.fillStyle = "#111";
						break;
					case SLOWER:
						ctx.fillStyle = "#a99";
						break;
					case SNAKE1:
						ctx.fillStyle = '#0ff';
						break;
					case SNAKE2:
						ctx.fillStyle = '#F49600';
						break;
				}
				ctx.fillRect(x * tw, y * th, tw, th);
			}
		}
	}

	function stopGame() {
		debugger;
		snake1.speed = STOPED;
		snake2.speed = STOPED;
	}

	function continueGame() {		
		snake1.speed = NORMAL;
		snake2.speed = NORMAL;
		init();
	}

	main();

</script>
</body>
</html>
